# Cryptohack ZKP Proofs of Knowledge

"""
Zero knowledge proofs are a tool in modern cryptography which allows you to prove that you know some witness which satisfies a relation, without revealing what the witness is. This has applications everywhere from signature schemes and privacy preserving cryptocurrencies, to one of the building blocks of secure multiparty computation.

For this first set of challenges, we are going to be looking at a protocol for proving knowledge of a discrete logarithm. The Prover (P) wants to prove to the Verifier (V) that she knows some witness w such that g^w = y mod p where g generates a group Fp where computing the Discrete Logarithm (DLOG) is hard. 

"""

# More generally, we talk about a proving knowledge of the public information (the "statement") and the witness satisfying some relation, for example, for the DLOG relation R_dlog. We have statement (p,q,g,y) defining a subgroup of Fp generated by g of order q, where p,q are prime, and y is an element of the subgroup. The "Witness" w is then the discrete logarithm of y with respect to g, which we denote as tuple ((p,q,g,y),w)∈Rdlog

"""

We start with a simple interactive protocol by Schnorr to prove knowledge of a discrete logarithm for public parameters x=(p,q,g,y) and private input w where g^w = y mod p.

Note that z is computed modulo q. This is because these operations are happening in the "exponent" of the verification equation, where the group generated by g has order q.

"""

"""
Note the three message form of this protocol:

    P sends some message aa to V
    V sends a random t-bit string to P (the challenge)
    P sends some message z to V. V now decides to accept or reject (⊤,⊥)(⊤,⊥) based on (x,a,e,z)


This is an instance of a so-called Sigma protocol, often denoted Σ-Protocol. A type of zero-knowledge proof with many nice properties.

To show that something of this structure is a Σ-Protocol, there are three additional properties the protocol has to satisfy, which we will now introduce over the next three challenges:

    Completeness: if P,V run the protocol on public input x and private input w, where (x,w)∈R, then V returns ⊤.
    Special Soundness: "If P can convince V, then P knows w"
    SHVZK: "V doesn't learn anything about w from P" 



We will discuss Special Soundness and SHVZK (Special-Honest-Verifier-Zero-Knowledge) more in following challenges. For now, lets start with Completeness!

"""

#  The aim of this challenge series is to give a first introduction to the key concepts of modern zero knowledge protocols. For those wishing to see a more formal treatment, I recommend resources such as the Σ-Protocols lecture notes by Damgård on which served as the inspiration for some of these challenges.

# Note: The next few challenges in this set aren't built to be difficult "CTF" challenges, but rather built to give you an intuition for how we construct and prove the security of Zero Knowledge protocols. For people interested in learning, it's recommended for your solve scripts to try and follow the protocol/challenge suggestions in your solve scripts as well. (For example, making sure to sample r randomly each time rather than fixing it, etc.) 

# Can you implement P's side of the protocol, and prove to the server that you know a witness w that satisfies the relation y = g^w mod P, making it return accept?

# Challenge File 

"""

import random
from utils import listener


FLAG = "crypto{????????????????????????}"

# Diffie-Hellman group (512 bits)
# p = 2*q + 1 where p,q are both prime, and 2 modulo p generates a group of order q
p = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55ef
q = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7
g = 2


# w,y for the relation `g^w = y mod P` we want to prove knowledge of
# w = random.randint(0,q)
# y = pow(g,w,P)
w = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83
y = 0x514c8f56336411e75d5fa8c5d30efccb825ada9f5bf3f6eb64b5045bacf6b8969690077c84bea95aab74c24131f900f83adf2bfe59b80c5a0d77e8a9601454e5

assert (y%p) >= 1
assert pow(y, q, p) == 1

class Challenge:
    def __init__(self):
        self.before_input = "Prove to me that you know an w such that g^w = y mod p. Send me a = g^r mod p for some random r in range(q)\n"
        self.state = "CHALLENGE"

    def challenge(self, msg):
        if self.state == "CHALLENGE":
            # Prover sends a randomly sampled `A` value from Z_p* to verifier
            self.a = msg["a"]
            if (self.a%p) < 1 or pow(self.a, q, p) != 1:
                self.exit = True
                return {"error": "Invalid value"}

            # Verifier sends a random challenge sampled from range(0, 2^t) where 2^t <= q
            self.e = random.randint(0,2**511)
            self.state = "PROVE"
            return {"e": self.e, "message": "send me z = r + e*w mod q"}
        elif self.state == "PROVE":
            # Prover sends z = r + e*w mod q to the Verifier
            z = msg["z"]

            self.exit = True

            # Verifier checks g^z = A*h^e mod p
            if pow(g,z,p) == (self.a*pow(y,self.e,p)) % p:
                return {"flag": FLAG, "message": "You convinced me you know an `w` such that g^w = y mod p!"}
            else:
                return {"error": "something went wrong :("}


import builtins; builtins.Challenge = Challenge # hack to enable challenge to be run locally, see https://cryptohack.org/faq/#listener
listener.start_server(port=13425)

"""





